const express=require("express"),mongoose=require("mongoose"),morgan=require("morgan"),methodOverride=require("method-override"),passport=require("passport"),cors=require("cors"),{param:param,matchedData:matchedData,validationResult:validationResult,body:body,checkExact:checkExact}=require("express-validator"),models=require("./models.js"),auth=require("./auth.js"),app=express(),movies=models.movie,users=models.user,directors=models.director,genres=models.genre;function _checkFieldInCollection(request,field,collection,errorMessage){return request(field,errorMessage).custom((async id=>!!await collection.findById(id)||Promise.reject()))}function _ifFieldEmptyBail(request,field,message,bailLevel="request"){return request(field,message).notEmpty().bail({level:bailLevel})}function _validateFavourites(){return body("favourites","Favourites must be an non empty array").isArray({min:1}).optional({values:"falsy"}).custom((async favourites=>{for(const id of favourites)if(!await movies.findById(id))return Promise.reject("Invalid movie ID in favourites.");return!0}))}function _valiDate(request,field,errorMessage){return request(field,errorMessage).custom((value=>!isNaN(Date.parse(value))))}mongoose.connect(process.env.CONNECTION_URI),app.use(cors({origin:(origin,callback)=>callback(null,!0)})),app.use(morgan("common")),app.use(express.static(__dirname)),app.use(express.urlencoded({extended:!0})),app.use(express.json()),auth(app),require("./passport.js"),app.post("/directors",passport.authenticate("jwt",{session:!1}),(async(req,res)=>{await directors.findOne({name:req.body.name}).then((director=>{if(director)return res.status(400).send(req.body.name+" already exists.");directors.create({name:req.body.name,birthday:req.body.birthday,deathday:req.body.deathday,biography:req.body.biography}).then((director=>{res.status(201).json(director)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.get("/directors?:limit",((req,res)=>{req.query.limit&&/^[1-9]\d*$/.test(req.query.limit)?directors.find().limit(parseInt(req.query.limit)).then((directors=>res.status(200).json(directors))).catch((err=>{console.error(err),res.status(500).send("Error: "+err)})):directors.find().then((directors=>res.status(200).json(directors))).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.get("/directors/:name",((req,res)=>{directors.findOne({name:req.params.name}).then((director=>{if(!director)return res.status(404).send(req.params.name+" was not found.");res.status(200).json(director)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.get("/genres?:limit",((req,res)=>{req.query.limit&&/^[1-9]\d*$/.test(req.query.limit)?genres.find().limit(parseInt(req.query.limit)).then((genres=>{if(0===genres.length)return res.status(404).send("No genres found.");res.status(200).json(genres)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)})):genres.find().then((genres=>{if(0===genres.length)return res.status(404).send("No genres found.");res.status(200).json(genres)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.get("/genres/:name",((req,res)=>{genres.findOne({name:req.params.name}).then((genre=>{if(!genre)return res.status(404).send(req.params.name+" was not found.");res.status(200).json(genre)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.post("/genres",passport.authenticate("jwt",{session:!1}),((req,res)=>{genres.findOne({name:req.body.name}).then((genre=>{if(genre)return res.status(400).send(req.body.name+" already exists.");genres.create({name:req.body.name,description:req.body.description}).then((genre=>{res.status(201).json(genre)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.get("/movies/:title",((req,res)=>{movies.findOne({title:req.params.title}).populate("genre").populate("director").then((movie=>{if(!movie)return res.status(404).send(req.params.title+" was not found.");res.status(200).json(movie)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.get("/movies?:limit",((req,res)=>{req.query.limit&&/^[1-9]\d*$/.test(req.query.limit)?movies.find().limit(parseInt(req.query.limit)).populate("genre").populate("director").then((movies=>{if(0===movies.length)return res.status(404).send("No movies found.");res.status(200).json(movies)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)})):movies.find().populate("genre").populate("director").then((movies=>{if(0===movies.length)return res.status(404).send("No movies found.");res.status(200).json(movies)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.post("/movies",[passport.authenticate("jwt",{session:!1}),_ifFieldEmptyBail(body,"title","The title is required"),_ifFieldEmptyBail(body,"description","The description is required"),_ifFieldEmptyBail(body,"genre","A genre ID is required"),_ifFieldEmptyBail(body,"director","A director ID is required"),_ifFieldEmptyBail(body,"imagePath","imagePath can't be empty").optional({values:"falsy"}),body("title","Movie already exists in the database.").custom((async title=>!await movies.findOne({title:title})||Promise.reject())).bail({level:"request"}),_checkFieldInCollection(body,"genre",genres,"Genre not found in database.").bail({level:"request"}),_checkFieldInCollection(body,"director",directors,"Director not found in database.").bail({level:"request"})],((req,res)=>{const errors=validationResult(req);if(!errors.isEmpty())return res.status(422).json({errors:errors.array()});const data=matchedData(req);movies.create({title:data.title,description:data.description,genre:data.genre,director:data.director,imagePath:data.imagePath?data.imagePath:null}).then((movie=>{res.status(201).json(movie)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.post("/users",[body("username","Username is required").isLength({min:5}).escape().bail({level:"request"}),body("username","Username contains non alphanumeric characters - not allowed.").isAlphanumeric().bail({level:"request"}),_ifFieldEmptyBail(body,"email","Email is required"),body("email","Email does not appear to be valid").isEmail().normalizeEmail().bail({level:"request"}),_ifFieldEmptyBail(body,"password","Password is required"),_valiDate(body,"birthday","Birthday is not a valid date.").bail({level:"request"}).optional({values:"falsy"}),_validateFavourites()],(async(req,res)=>{const errors=validationResult(req);if(!errors.isEmpty())return res.status(422).json({errors:errors.array()});const data=matchedData(req);await users.findOne({username:data.username}).then((async user=>{if(user)return res.status(400).send(data.username+" already exists.");users.create({username:data.username,password:users.hashPassword(data.password),email:data.email,birthday:data.birthday?data.birthday:null,favourites:data.favourites?data.favourites:null}).then((user=>{res.status(201).json(user)})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}))})),app.delete("/users/:username",[passport.authenticate("jwt",{session:!1}),param("username","username_required").isLength({min:5}).escape().bail({level:"request"}),param("username","not_allowed").custom(((value,{req:req})=>value===req.user.username))],(async(req,res)=>{let errors=validationResult(req);if(errors.isEmpty())await users.deleteOne({username:req.params.username}).then((result=>{if(0===result.deletedCount)return res.status(404).send(req.params.username+" was not found.");res.status(200).send(req.params.username+" was deleted.")})).catch((err=>{console.error(err),res.status(500).send("Error: "+err)}));else switch(errors=errors.array(),errors[0].msg){case"username_required":res.status(422).end("Please provide a valid username.");break;case"not_allowed":res.status(403).end("You are not allowed to delete this user!");break;default:res.status(422).json({errors:errors})}})),app.patch("/users/:username",[passport.authenticate("jwt",{session:!1}),param("username","username_required").isLength({min:5}).escape().bail({level:"request"}),param("username","not_allowed").custom(((value,{req:req})=>value===req.user.username)).bail({level:"request"}),checkExact([body("username","Username must be at least 5 characters long,").isLength({min:5}).escape().optional({values:"falsy"}),body("username","Username contains non alphanumeric characters - not allowed.").isAlphanumeric().escape().optional({values:"falsy"}),body("email","Email does not appear to be valid").isEmail().normalizeEmail().optional({values:"falsy"}),_ifFieldEmptyBail(body,"password","Password can't be empty.").optional({values:"falsy"}),_valiDate(body,"birthday","Birthday is not a vaild date").bail({level:"request"}).optional({values:"falsy"}),_validateFavourites()])],((req,res)=>{let errors=validationResult(req);if(errors.isEmpty()){const data=matchedData(req);if(1===Object.keys(data).length&&data.username===req.user.username)return res.status(400).send("No valid data provided.").end();console.log(data),users.findOneAndUpdate({username:req.params.username},data,{new:!0}).then((user=>user?res.status(200).send("Successfully updated user "+req.params.username):res.status(404).send(req.params.username+" was not found."))).catch((err=>(console.error(err),res.status(500).send("Error: "+err))))}else switch(errors=errors.array(),errors[0].msg){case"username_required":res.status(422).end("Please provide a valid username.");break;case"not_allowed":res.status(403).end("You are not allowed to update this user!");break;default:res.status(422).json({errors:errors}).end()}})),app.use(methodOverride()),app.use(((err,_,res,next)=>{console.error(err.stack),res.status(500).send("Something broke!"),next()}));const port=process.env.PORT||8e3;app.listen(port,"0.0.0.0",(()=>{console.log("Listening on port "+port)}));